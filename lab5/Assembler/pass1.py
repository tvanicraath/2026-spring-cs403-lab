from dataclasses import dataclass
from typing import Optional, TextIO
from . import bindings  # Auto-generated by ctypesgen from Lab 3
from .littab import LitTab

littab = LitTab()

class AssemblerError(Exception):
    """Custom exception for assembler errors."""
    pass

@dataclass
class SICTuple:
    """Represents a parsed line of SIC Assembly."""
    label: Optional[str] = None
    mnemonic: Optional[str] = None
    operand: Optional[str] = None

    def to_string(self, locctr: Optional[int], error: Optional[str]) -> str:
        """Formats the tuple for the intermediate file."""
        # Use 4-column format: Address, Label, Mnemonic, Operand
        loc_str = hex(locctr)[2:].upper() if locctr is not None else ""
        label_str = self.label or ""
        mnemonic_str = self.mnemonic or ""
        operand_str = self.operand or ""
        error_str = f"\t ! {error}" if error else ""
        return f"{loc_str}\t{label_str}\t{mnemonic_str}\t{operand_str}{error_str}"

class SICParser:
    """Handles text parsing of assembly source lines."""
    
    @staticmethod
    def parse(line: str) -> Optional[SICTuple]:
        """
        Parses a raw line into a SICTuple.
        Returns None for comments or empty lines.
        """
        if line.lstrip().startswith('.'):
            return None
        if '.' in line:
            line = line.split('.', 1)[0]  # Remove inline comment
        line = line.rstrip()
        if not line:
            return None

        # Split into max 3 parts: Label, Mnemonic, Operand
        parts = line.split(None, 2)
        has_label = not line[0].isspace()

        if has_label: #e.g.: FIRST   LDA     ALPHA
            label = parts[0]
            if len(label) > 16:
                raise AssemblerError(f"Label '{label}' exceeds 16 characters.")
            return SICTuple(
                label=parts[0],
                mnemonic=parts[1] if len(parts) > 1 else None,
                operand=parts[2] if len(parts) > 2 else None
            )
        else: #e.g.:    LDA     ALPHA
            return SICTuple(
                label=None,
                mnemonic=parts[0] if len(parts) > 0 else None,
                operand=parts[1] if len(parts) > 1 else None
            )

    @staticmethod
    def get_byte_length(operand: str) -> int:
        """Calculates memory size for BYTE directives."""
        if not operand: return 0
        if operand.startswith("C'"):
            return len(operand) - 3  # C'EOF' -> 3 bytes
        elif operand.startswith("X'"):
            hex_len = len(operand) - 3
            return (hex_len + 1) // 2  # X'F1' -> 1 byte and X'F12' -> 2 bytes
        return 0

class Pass1Assembler:
    def __init__(self, source_file: TextIO, target_file: TextIO):
        self.source_file = source_file
        self.target_file = target_file
        self.locctr = 0
        self.start_addr = 0
        self.program_name = "" 
        bindings.init_symtab()
    
    @property
    def program_length(self) -> int:
        return self.locctr - self.start_addr

    def _insert_symbol(self, label: str) -> bool:
        # returns 1 on success, 0 on duplicate, -1 on full
        return bindings.insert_symbol(label.encode('utf-8'), self.locctr)

    def _is_opcode(self, mnemonic: str) -> bool:
        # returns str of opcode on success and None on failure 
        return bool(bindings.search_optab(mnemonic.encode('utf-8')))

    def _emit(self, line: SICTuple, loc: Optional[int], error: Optional[str] = None):
        print(line.to_string(loc, error), file=self.target_file)

    def _flush_literals(self, limit_addr: int):
        """Processes and emits literals from the pool."""
        # LitTab has already assigned addresses; we just need to print the new ones.
        for lit_name, entry in littab.literals.items():
            if entry.address is not None and limit_addr <= entry.address < self.locctr:
                # Create a synthetic tuple for output: * =C'EOF'
                lit_line = SICTuple(label='*', mnemonic=lit_name, operand='')
                self._emit(lit_line, entry.address)

    def run(self):
        """Main execution loop for Pass 1."""
        
        for line in self.source_file:
            line = SICParser.parse(line)
            if not line or (not line.label and not line.mnemonic):
                continue # Skip empty lines or pure comments

            current_loc = self.locctr

            # --- 1. Handle START Directive ---
            if line.mnemonic == 'START':
                if line.label:
                    self.program_name = line.label
                if line.operand:
                    self.start_addr = int(line.operand, 16)
                    self.locctr = self.start_addr
                self._emit(line, self.locctr)
                continue

            # --- 2. Handle LTORG / END Directives ---
            if line.mnemonic in ['LTORG', 'END']:
                # if line.mnemonic == 'LTORG':
                    # self._emit(line, None) # Print LTORG directive first
                old_loc = self.locctr
                self.locctr = littab.assign_addresses(self.locctr)
                self._flush_literals(old_loc)
                if line.mnemonic == 'END':
                    self._emit(line, None) # Print END directive
                    break
                continue

            # --- 3. Symbol Handling ---
            if line.label:
                res = self._insert_symbol(line.label)
                if res == 0:
                    raise AssemblerError(f"Duplicate symbol '{line.label}' at {hex(current_loc)}")
                elif res == -1:
                    raise AssemblerError(f"Symbol Table Full when inserting '{line.label}'")

            # --- 4. Literal Handling ---
            if line.operand and line.operand.startswith('='):
                try:
                    littab.add_literal(line.operand)
                except Exception as e:
                    raise AssemblerError(f"LitTab Error: {e}")

            # --- 5. Address Update & Opcode Lookup ---
            if not line.mnemonic:
                # Label-only line
                self._emit(line, current_loc)
                continue

            if self._is_opcode(line.mnemonic):
                self.locctr += 3
            elif line.mnemonic == 'WORD':
                self.locctr += 3
            elif line.mnemonic == 'RESW':
                self.locctr += 3 * int(line.operand)
            elif line.mnemonic == 'RESB':
                self.locctr += int(line.operand)
            elif line.mnemonic == 'BYTE':
                self.locctr += SICParser.get_byte_length(line.operand)
            else:
                raise AssemblerError(f"Invalid mnemonic '{line.mnemonic}' at {hex(current_loc)}")

            # Emit the final processed line
            self._emit(line, current_loc)