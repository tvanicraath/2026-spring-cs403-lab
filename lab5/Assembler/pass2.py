import sys
from typing import Optional, TextIO, List
from . import bindings  # Auto-generated by ctypesgen from Lab 3
from .pass1 import SICTuple, AssemblerError, littab

class ObjectCode:
    """Generates SIC machine code from parsed intermediate lines."""

    @staticmethod
    def generate(instruction: SICTuple, loc: int) -> Optional[str]:
        """
        Converts a SICTuple into a hex string object code.
        Returns None if the line generates no code (e.g., RESW, START, END).
        Use provided bindings.search_optab function and helper methods _calculate_target_address and _convert_constant.
        """
        mnemonic = instruction.mnemonic
        operand = instruction.operand

        # --- 1. Handle Directives ---
        if mnemonic in ('START', 'END', 'LTORG', 'RESB', 'RESW'):
            return None

        # --- 2. Handle Constants ---
        elif mnemonic in ('BYTE', 'WORD', '*'):
            # e.g. BYTE C'EOF' -> 454F46, BYTE X'F1' -> F1, WORD 10 -> 00000A
            # e.g. line: 1012 * =C'EOF' -> label='*', mnemonic='*', operand='=C'EOF''
            return ObjectCode._convert_constant(operand)

        # --- 3. Handle Standard Instructions ---
        opcode_str = bindings.search_optab(mnemonic.encode('utf-8'))
        if opcode_str is None:
            raise AssemblerError(f"Unknown Mnemonic: {mnemonic}")

        opcode_val = int(str(opcode_str), 16)
        target_address = ObjectCode._calculate_target_address(operand)
        # Format: Opcode(8) + Address(15 + X)
        return f"{opcode_val:02X}{target_address:04X}"

    
    @staticmethod
    def _calculate_target_address(operand: str) -> int:
        """Calculates the target address for an instruction operand."""
        if not operand:
            return 0
        is_indexed = operand.endswith(',X') 
        token = operand[:-2] if is_indexed else operand
        addr = bindings.search_symbol(token.encode('utf-8'))
        if addr == -1: # address not found in symtab, might be a literal
            addr = littab.get_address(token)
            if addr is None:
                raise AssemblerError(f"Undefined Symbol: {token}")
        if is_indexed:
            addr |= 0x8000 # Set X bit
        return addr

    @staticmethod
    def _convert_constant(const_str: str) -> str:
        """Helper to convert C'EOF' or X'F1' to hex string."""
        if not const_str: return ""
        
        # Handle =C'...' or C'...'
        if const_str.startswith('=C') or const_str.startswith("C'"):
            content = const_str.split("'")[1]
            return "".join(f"{ord(c):02X}" for c in content)
        
        # Handle =X'...' or X'...'
        elif const_str.startswith('=X') or const_str.startswith("X'"):
            content = const_str.split("'")[1]
            return content.upper()
        
        # Handle Decimal constants in WORD (e.g., 10 -> 00000A)
        else:
            try:
                val = int(str(const_str), 10)
                return f"{val:06X}"
            except ValueError:
                raise AssemblerError(f"Invalid constant: {const_str}")


class IntermediateLineParser:
    """Parses the specific tab-separated output from Pass 1."""
    
    @staticmethod
    def parse(line: str) -> tuple[Optional[int], Optional[SICTuple]]:
        """
        Parses a line from intermediate file.
        Format expected: Address \t Label \t Mnemonic \t Operand
        Returns (Address, SICTuple)
        """
        parts = line.split('\t')
        if parts[2] == "END":
            # e.g. line:     END  INPUT
            return None, SICTuple(label=None, mnemonic='END', operand=parts[3])
        elif parts[1] == '*':
            # e.g. line: 1012 * =C'EOF'
            addr = int(parts[0], 16)
            return addr, SICTuple(label='*', mnemonic='*', operand=parts[2])
        else:
            addr_str = parts[0]
            if addr_str:
                try:
                    current_loc = int(addr_str, 16)
                except ValueError:
                    current_loc = None
            sic_tuple = SICTuple(label=parts[1], mnemonic=parts[2], operand=parts[3])
            return current_loc, sic_tuple


class Pass2Assembler:
    def __init__(self, intermediate_file: TextIO, obj_file: TextIO, program_name: str, start_addr: int, program_length: int):
        self.source_file = intermediate_file
        self.target_file = obj_file
        
        self.program_name = program_name
        self.start_addr = start_addr
        self.program_length = program_length
        
        # Text Record Buffering
        self.text_buffer: List[str] = []
        self.text_start_addr: Optional[int] = None
        self.current_text_len_bytes = 0

    def _write_header(self):
        """Writes Header Record: H^NAME^START^LENGTH (without ^)"""
        print(f"H{self.program_name:<6}{self.start_addr:06X}{self.program_length:06X}", file=self.target_file)

    def _flush_text_record(self):
        """Writes the current buffered Text Record to file."""
        if not self.text_buffer:
            return

        # Join codes
        obj_code_str = "".join(self.text_buffer)
        
        # Write Record: T^Start^Length^Codes (without ^)
        print(f"T{self.text_start_addr:06X}{self.current_text_len_bytes:02X}{obj_code_str}", file=self.target_file)

        # Reset Buffer
        self.text_buffer = []
        self.text_start_addr = None
        self.current_text_len_bytes = 0
    
    def _debug_code(self, tup: SICTuple, loc: int, obj_code: Optional[str]):
        """Helper to print debug info about generated code."""
        print(f'Generated Object Code for "{tup.mnemonic} {tup.operand}": {obj_code}')

    def _add_to_text_record(self, code: str, addr: int):
        """Adds object code to buffer, flushing if full."""
        code_len_bytes = len(code) // 2

        # 1. Initialize start address if new record
        if self.text_start_addr is None:
            self.text_start_addr = addr

        # 2. Check limits (Max 30 bytes per record)
        if self.current_text_len_bytes + code_len_bytes > 30:
            self._flush_text_record()
            self.text_start_addr = addr

        # 3. Add to buffer
        self.text_buffer.append(code)
        self.current_text_len_bytes += code_len_bytes

    def _write_end(self, first_exec_addr: int):
        """Writes End Record: EFirstAddr"""
        print(f"E{first_exec_addr:06X}", file=self.target_file)

    def run(self):
        """Main execution loop for Pass 2."""

        self._write_header() 

        for line in self.source_file:
            # Write code here according to the instructions in readme.md
            pass